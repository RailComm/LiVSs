#
# Author: Alexander Dean <dstar@csh.rit.edu>
# Copyright (c) 2011, RailComm LLC
# All rights reserved. Redistribution and use in source and binary forms, with 
# or without modification are permitted provided that the conditions are met 
# under the Modified BSD License.
#
"""A LiVSs Script file is a file that LiVSs can use to generate its 
internal configuration. It does so by first loading it in, and if python 
can interpret it. Then it will run it. This means all LiVSs scripts must 
be valid python code as well. However the way LiVSs scripts are layed out 
are much simpler. (ie, all you have to do is write a function called run() 
and fill it with variables.)
"""
import re
import imp
import sys
import inspect
import logging

_desc_="""\"\"\"
This is a default script file for LiVSs. If you pass this file directly into
LiVSs, it will NOT work as these are default values. Change these values to 
meet your requirements and then run the command:
                        livss script <name_of_file>
\"\"\"
###### Always start your script with this function header ####
"""
_default_ = """def run():
    ## IO ##
    input  = None
    output = '-'
    
    ## logging ##
    log_debug    = False
    log_warnings = False
    log_path   = 'errors.log'
    log_format   = "%(levelname)-8s::[%(asctime)s]-%(funcName)s@%(lineno)d %(message)s"
    log_date_format = "%a, %d %b %Y %H:%M:%S"
    
    ## command headers ##
    ### IGNORE THESE, scripts get these variables inferred magically ###
    subparser_name=None
    subsubparser_name=None
    script_save_path = ''
    
    ## exporting commands ##
    export_util_menus   = False
    export_util_dialogs = False
    export_util_strings = False
    export_util_all     = False
    export_util_levels  = ''
    export_util_mem     = False
    export_translator_levels = ''
    export_translator_mem    = False

    ## update commands ##
    update_translator = None
    update_dialogs    = None
    update_menus      = None
    update_strings    = None
    update_resource   = None
    update_level      = None
    update_who        = None

    #### Remember to return all the variables at the end of your function #####
    return locals()
###############################################################################
"""

_top_ = """\"\"\"...THIS SCRIPT WAS GENERATED BY HEADSHOT...\"\"\"\n"""
_head_= "def run():\n"
_foot_= "\treturn locals()\n"

class LSScript( ):
    def __init__(self, path):
        self._path = path
    
    def run(self):
        """We essentially want to run the module we just loaded via the
        python importer. So if everything went alright, this should just
        work.
        """
        try:
            global _MagicModule
            imp.load_source("_MagicModule", self._path)
            import _MagicModule #@UnresolvedImport
            return _MagicModule.run() #returns the locals
        except: raise

    def dumpDefault(self, newpath=None):
        """Dumps a default script file into a given path."""
        if newpath is not None: self._path = newpath
        global _desc_, _default_
        with open(self._path, 'w+') as script:
            script.write(_desc_)
            script.write(_default_)

    def dumpCfgs(self, cfgs, imports=None, newpath=None):
        """Dumps the configs that are given, into the cfg file."""
        myimports = []
        if newpath is not None: self._path = newpath
        if imports is not None: myimports = imports
        global _top_, _head_, _foot_
        with open(self._path, 'w+') as script:
            script.write(_top_)
            script.write(_head_)
            for imps in myimports:
                if inspect.ismodule(imps):
                    script.write(self.__makeimport(imps))
                script.write("\timport %s\n"%imps)
            for name, value in cfgs.items():
                script.write(self.__makestr(name, value))
            script.write(_foot_)
    
    
    def __makeimport(self, simp):
        # this is a BAD idea... but im not sure of a better way at the moment.
        tmp = str(simp)
        match = re.search("^<.* '(.*?)' .*?>$", tmp)
        if match is None: return ''
        else: return '\timport %s\n'%match.groups()[0]
    
    def __makestr(self, name, val):
        #Converts a name,value pair into a correct line of python code.
        if type(val) is str: return "\t%s = \"%s\"\n"%(name, val)
        elif type(val) in [dict, tuple, list, bool, int, float, complex, type(None)]: 
            return "\t%s = %s\n"%(name, str(val))
        elif inspect.ismodule(val): return self.__makeimport(val)
        # Checks for normal imports. This should be cleaner, but I'm doing
        # this quickly, and since it works there is no real reason to do it
        # otherwise.
        elif val == sys.stdout: return "\t%s = sys.stdout\n" % name
        elif val == sys.stdin:  return "\t%s = sys.stdin\n"  % name
        elif val == sys.stderr: return "\t%s = sys.stderr\n" % name
        #
        # TODO: Need more special imports here, or try to automate it.
        #
        else: 
            logging.error("Failed to predict values when saving hsscript: %s:%s"%(name,str(val)))
            return "\t%s = %s\n"%(name, str(val))
            